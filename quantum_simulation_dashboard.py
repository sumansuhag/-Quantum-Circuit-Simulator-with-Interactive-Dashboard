# -*- coding: utf-8 -*-
"""Quantum Simulation Dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/197roa6CBa1UPk-zA6SuyNlkj9EY8Gb3Q
"""

!pip install qiskit
#!pip install qiskit-aer
#!pip install qiskit[visualization]
!pip install qiskit-aer

# Import necessary libraries
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator

# Create a Quantum Circuit with 1 qubit and 1 classical bit
qc = QuantumCircuit(1, 1)

# Apply a Hadamard gate to the qubit
qc.h(0)

# Measure the qubit
qc.measure(0, 0)

# Print the Quantum Circuit
print(qc)

# Run the Quantum Circuit on a simulator
simulator = AerSimulator()
qc_compiled = transpile(qc, simulator)
job = simulator.run(qc_compiled)
result = job.result()

# Print the result
print(result.get_counts())

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
import time

qc = QuantumCircuit(1, 1)
qc.h(0)
qc.measure(0, 0)

print("Quantum Circuit:")
print(qc.draw())

simulator = AerSimulator()

start_time = time.time()
job = simulator.run(qc, shots=1000)
end_time = time.time()

result = job.result()
counts = result.get_counts(qc)

print("\nMeasurement Results:")
print(counts)

total_time = end_time - start_time
print(f"\nTotal Running Time: {total_time:.6f} seconds")

# Calculate probabilities
total_counts = sum(counts.values())
probabilities = {key: value / total_counts for key, value in counts.items()}

print("\nProbabilities:")
for state, prob in probabilities.items():
    print(f"P({state}) = {prob:.4f}")

""" Simple quantum circuit that creates a superposition of two states and measures the result. The code is kept minimal to reduce complexity"""

# Import necessary libraries
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram

# Create a Quantum Circuit with 1 qubit and 1 classical bit
qc = QuantumCircuit(1, 1)

# Apply a Hadamard gate to create superposition
qc.h(0)

# Measure the qubit
qc.measure(0, 0)

# Use the Aer's qasm_simulator
simulator = AerSimulator()

# Execute the circuit
job = simulator.run(qc, shots=1000)
result = job.result()

# Get the counts
counts = result.get_counts(qc)

# Print the measurement results
print("Measurement Results:", counts)

# Plot the histogram of results
plot_histogram(counts)

# Import necessary libraries
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
from sklearn.decomposition import PCA
import numpy as np
import matplotlib.pyplot as plt

# Create a Quantum Circuit with 1 qubit and 1 classical bit
qc = QuantumCircuit(1, 1)

# Apply a Hadamard gate to create superposition
qc.h(0)

# Measure the qubit
qc.measure(0, 0)

# Use the Aer's qasm_simulator
simulator = AerSimulator()

# Execute the circuit
job = simulator.run(qc, shots=1000)
result = job.result()

# Get the counts
counts = result.get_counts(qc)

# Print the measurement results
print("Measurement Results:", counts)

# Plot the histogram of results
plot_histogram(counts)

# Perform PCA on the measurement results
pca = PCA(n_components=2)
data = np.array([list(counts.keys()), list(counts.values())]).T
pca_data = pca.fit_transform(data)

# Plot the PCA results
plt.figure(figsize=(8, 6))
plt.scatter(pca_data[:, 0], pca_data[:, 1])
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('PCA of Measurement Results')
plt.show()

!pip install dash

#Import necessary libraries
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
import plotly.express as px
import numpy as np

# Create a Dash app
app = dash.Dash(__name__)

# Define the layout of the app
app.layout = html.Div([
    html.H1('Quantum Circuit Simulator'),
    html.P('Number of shots:'),
    dcc.Input(id='shots', type='number', value=1000),
    html.Button('Run Simulation', id='run-button', n_clicks=0),
    html.Div(id='output'),
    html.Div(id='histogram')
])

# Define the callback function for the run button
@app.callback(
    [Output('output', 'children'),
     Output('histogram', 'children')],
    [Input('run-button', 'n_clicks')],
    [dash.dependencies.State('shots', 'value')]
)
def run_simulation(n_clicks, shots):
    # Create a quantum circuit
    qc = QuantumCircuit(1, 1)
    qc.h(0)
    qc.measure(0, 0)

    # Run the simulation
    simulator = AerSimulator()
    job = simulator.run(qc, shots=shots)
    result = job.result()
    counts = result.get_counts(qc)

    # Create a histogram of the results
    histogram = plot_histogram(counts)

    # Return the output and histogram
    return f'Simulation ran with {shots} shots', dcc.Graph(figure=histogram)

# Run the app
if __name__ == '__main__':
    app.run(debug=True)